* To do list for keyer.js
** [x] keyboard source to morse and text
** [x] visible frame for keyboard input
** [x] style button text to match elsewhere
** [x] make scheme colors available inside RecriKeyer.js
** [ ] color input text according to sent/skipped/pending status
*** It turns out that I cannot use contenteditable and lit-html
    in the same node, so I need to rewrite the contents of the
    div in the dom myself.
*** That is simplified in that I will usually only be moving
    text from one node to another, so I can keep the skeleton
    of the DOM as it is.
***  Can I enclose <br> in <span></span>?  Yes, but it's not
    nice for screen readers.
***   There is a neat snippet to make contenteditable not insert
    div's, only br's: display: inline-block;
***   This snippet will move the editor caret to the end of text
    in an element.
	    var range = document.createRange();
            range.selectNodeContents(el);
            range.collapse(atStart);
            var sel = window.getSelection();
            sel.removeAllRanges();
            sel.addRange(range);
*** This snippet will find the div with class="keyboard"
    var el = document.querySelector(".keyboard");
*** I can probably enclose all the sent and skipped text
    inside one <span class="sent" contenteditable="false">
    by enclosing the <span class="skip">text</span> spans
    inside of it, along with text nodes and <br>'s.
** [ ] write a <pre> component for viewing the text windows
   contents.
** [x] enable backspace for limited editing of input text
** [x] enable newline to insert <br> of input text
** [x ] explore the contenteditable solution to input text
** [ ] cancel button
** [ ] edit color of input text classes
** [x] define material design color set
** [ ] use material design color set
** [x] play/pause button
** [x] keyboard source to straight key
** [x] keyboard source to iambic key
** [x] select keyboard key for straight key
** [x] select keyboard keys for iambic paddle
** [ ] select midi events for straight key
** [ ] select midi events for iambic paddle
** [x] see if left/right is in the event
   yes, it's in e.code
** [x] midi source to straight key
** [x] midi source to iambic key
** [ ] and bug keyer
** [ ] and ultimatic keyer
** [ ] fix KeyerDetone
** [ ] fix KeyerDetime
   straight key wants detime for decoder
** [ ] decode microphone tone source
** [ ] decode microphone sung source
** [ ] webrtc tone sink
** [ ] webrtc tone source
** [x] limited menu of envelopes
** [ ] full window menu for envelope
   window functions make nice keying envelopes
** [ ] animated straight key logo
** [x] a nice straight key logo
** [x] a nice favicon
** [ ] factor KeyerSink from KeyerOutput
** [x] factor KeyerSource from KeyerInput
** [x] refactor Input -> Input/Source
** [ ] refactor Output -> Output/Sink
** [x] does KeyerPlayer.connect() ever get called?
   gets called to connect to the destination.
** [x] incorporarate PWA functionality
** [x] push to netlify
** [x] controls don't render update on change
** [x] speed control is a no-op
** [x] one size fits all logo is too chunky
** [x] solve window not fitting viewport
   used css to resize logo to fit
** [x] icons need to be maskable
   ie, content can be masked to radius 40% circle without
   losing out.  Most were that way already.
** [x] multiple input spaces collapsed to single by html
** [x] iambic needs gain twiddle to start playing
   twiddled it at startup
** [x] straight needs gain twiddle to start playing
   turned out that straight key worked fine
** [x] implement weight and the other key bending controls from recri/keyer
   #if FRAMEWORK_OPTIONS_KEYER_OPTIONS_WEIGHT
   { "-weight",	 "weight",    "Weight",  "50",	    fw_option_float,    fw_flag_none,	    offsetof(_t, opts.weight),	  "keyer mark/space weight" },
   #endif
   #if FRAMEWORK_OPTIONS_KEYER_OPTIONS_RATIO
   { "-ratio",	 "ratio",    "Ratio",    "50",	    fw_option_float,    fw_flag_none,	    offsetof(_t, opts.ratio),	  "keyer dit/dah ratio" },
   #endif
   #if FRAMEWORK_OPTIONS_KEYER_OPTIONS_COMP
   { "-comp",     "comp",     "Comp",      "0",	    fw_option_float,    fw_flag_none,	    offsetof(_t, opts.comp),       "keyer ms compensation" },
   #endif
	parts per thousand = per mille = â€°
	    {* -weight} - 
	    {* -ratio} { $self describe $option value -format %.1f -min 25.0 -max 75.0 -step 0.1 -units % -graticule 20 -steps-per-div 50}
	    {* -comp} { $self describe $option value -format %.1f -min -15.0 -max 15.0 -step 0.1 -units ms -graticule 20 -steps-per-div 50}
      float r = (dp->opts.ratio-50)/100.0; // why 50 is zero is left as an exercise
      float w = (dp->opts.weight-50)/100.0;
      float c = 1000.0 * dp->opts.comp / microsPerDit;
      dp->k.k.setTiming(1000000.0  / sdrkit_sample_rate(dp),
			dp->opts.wpm, 
			dp->opts.word, 
			dp->opts.dit+r+w+c, 
			dp->opts.dah-r+w+c,
			dp->opts.ies  -w-c, 
			dp->opts.ils  -w-c, 
			dp->opts.iws  -w-c);
** [x] collapse out some irrelevant UI components
** [ ] hide/show parts of settings according to properties
   I can do this by conditionally including/excluding html`` for each part,
   however, I think lit-html works better if I render the whole thing and
   mark parts as displayed/hidden according to the same conditions.
   so that's the css property { display: none; } to disappear,
   { display: block } to show a div.
   Menu marker characters:
***   &#x23f4; left filled triangle
***   &#x23f5; right filled triangle
***   &#x23f6; up filled triangle
***   &#x23f7; down filled triangle
***   &#9776; hamburger menu, all yang trigram
***   &#x23F5; Play button
***   &#x25B6; Play button emoji
***   &#xe23a; Play button emoji
***   &#x23F8; Pause button    
***   &#xFE0F; Pause button emoji

** [ ] Oh, to avoid the nasty message about web audio in the console, I have to avoid
   opening an AudioContext until I'm in a user initiated gesture.  That is, the
   whole chain of objects I create cannot be created until the first click on Play,
   or I need to rewrite them all to take implement a set context().
** [ ] Separate Key and Keyer.  Key can be 'straight' or 'paddle'.
** [ ] A Key which is a 'paddle' can have a Keyer which could be
   'iambic-a', 'iambic-b', 'bug', 'ultimatic', or 'swiper'.
** [ ] No idea how to avoid the nasty message from web midi.
** [ ] Discovered chrome.socket.udp today, so an HL2 PWA is going to happen.
** [-] Rewriting pulse shaping using independently timed buffers was frustrating,
   couldn't find a way to do it and backed out.
** [ ] Write a scope web-component.
   
