* To do list for keyer.js
** [ ] oh, localStorage only works for string values.
   so that's why my Boolean values failed
   and that's why my Array value is failing.
** [ ] changing sample rate is wonky
** [ ] resetting to defaults is wonky
** [ ] pops in straight keying
** [ ] additional ramp functions   
** [x] add sampleRate selector
** [x] rearrange Settings
** [ ] make input Settings optionally copy output Settings
** [ ] merge keyed input into window
** [ ] edit color of input text classes
** [ ] use material design color set
** [ ] use css variables to setup color set
** [ ] Separate Key and Keyer.  Key can be 'straight' or 'dual-lever' or 'single-lever'
** [ ] A Key which is a 'paddle' can have a Keyer which could be
   'iambic-a', 'iambic-b', 'bug', 'ultimatic', or 'swiper'.
** [ ] slant touch keys 
** [x] rewrite the event handler to eliminate ctx
** [x] rewrite the event handler to be instance again
	requires rewriting the KeyerEvent class back the way it was
	and requires making sure that every event listener attaches
	to the correct event source.
	or should they bubble?
** [x] rewrite events to attach to the correct targets.
** [x] fix the straight key glitch with Midi input
** [x] refresh the Midi names and Midi notes while displayed
** [?] rewrite Midi handling to simply number the devices
   and accumulate notes as device:channel:note
   strings and ignore the names entirely.
** [?] It would be nice to make the key device come out at the
   same number to preserve the binding
** [?] then again, if you only get two notes, just assign them
   and be done.
** [x] color input text according to sent/skipped/pending status
*** It turns out that I cannot use contenteditable and lit-html
    in the same node, so I need to rewrite the contents of the
    div in the dom myself.
*** That is simplified in that I will usually only be moving
    text from one node to another, so I can keep the skeleton
    of the DOM as it is.
***  Can I enclose <br> in <span></span>?  Yes, but it's not
    nice for screen readers.
***   There is a neat snippet to make contenteditable not insert
    div's, only br's: display: inline-block;
***   This snippet will move the editor caret to the end of text
    in an element.
	    var range = document.createRange();
            range.selectNodeContents(el);
            range.collapse(atStart);
            var sel = window.getSelection();
            sel.removeAllRanges();
            sel.addRange(range);
** This snippet will find the div with class="keyboard"
    var el = document.querySelector(".keyboard");
*** I can probably enclose all the sent and skipped text
    inside one <span class="sent" contenteditable="false">
    by enclosing the <span class="skip">text</span> spans
    inside of it, along with text nodes and <br>'s.
** [x] cancel button
** [?] write a <pre> component for viewing the text windows
   contents.
** [ ] make a bug keyer
** [ ] make an ultimatic keyer
** [ ] make an iambic A keyer
** [ ] fix KeyerDetone
** [x] fix KeyerDetime
   straight key wants detime for decoder, it works, both straight key, iambic,
   and output keyer are decoded from transitions
** [ ] decode microphone tone source
** [ ] decode microphone sung source
** [ ] webrtc tone sink
** [ ] webrtc tone source
** [x] Oh, to avoid the nasty message about web audio in the console, I have to avoid
   opening an AudioContext until I'm in a user initiated gesture.  That is, the
   whole chain of objects I create cannot be created until the first click on Play,
   or I need to rewrite them all to take implement a set context().
   Or place a KeyerStub between KeyerJs and Keyer, or just defer making anything
   until the user starts the program.
** [ ] No idea how to avoid the nasty message from web midi.
   but it isn't so nasty, Lighthouse ignores it.
** [ ] Discovered chrome.socket.udp today, so an HL2 PWA is going to happen.
** [ ] Write a scope web-component.
** [x] keyboard source to morse and text
** [x] visible frame for keyboard input
** [x] style button text to match elsewhere
** [x] make scheme colors available inside RecriKeyer.js
** [x] enable backspace for limited editing of input text
** [x] enable newline to insert <br> of input text
** [x] explore the contenteditable solution to input text
** [x] define material design color set
** [x] play/pause button
** [x] keyboard source to straight key
** [x] keyboard source to iambic key
** [x] select keyboard key for straight key
** [x] select keyboard keys for iambic paddle
** [x] select midi events for straight key
** [x] select midi events for iambic paddle
** [x] see if left/right is in the event
   yes, it's in e.code of keyboard shifts
** [x] midi source to straight key
** [x] midi source to iambic key
** [x] limited menu of envelopes
** [x] full window menu for envelope
   window functions make nice keying envelopes
   only implemented 
*** sine (raised-cosine), 
*** blackman-harris,
*** exponential (ala capacitor charging)
*** and linear.
** [?] animated straight key logo
** [x] a nice straight key logo
** [x] a nice favicon
** [?] factor KeyerSink from KeyerOutput
   need to find alternate sinks.
** [x] factor KeyerSource from KeyerInput
** [x] refactor Input -> Input/Source
** [?] refactor Output -> Output/Sink
** [x] does KeyerPlayer.connect() ever get called?
   gets called to connect to the destination.
** [x] incorporarate PWA functionality
** [x] push to netlify
** [x] controls don't render update on change
** [x] speed control is a no-op
** [x] one size fits all logo is too chunky
** [x] solve window not fitting viewport
   used css to resize logo to fit
** [x] icons need to be maskable
   ie, content can be masked to radius 40% circle without
   losing out.  Most were that way already.
** [x] multiple input spaces collapsed to single by html
** [x] iambic needs gain twiddle to start playing
   twiddled it at startup
** [x] straight needs gain twiddle to start playing
   turned out that straight key worked fine
** [x] implement weight and the other key bending controls from recri/keyer
   #if FRAMEWORK_OPTIONS_KEYER_OPTIONS_WEIGHT
   { "-weight",	 "weight",    "Weight",  "50",	    fw_option_float,    fw_flag_none,	    offsetof(_t, opts.weight),	  "keyer mark/space weight" },
   #endif
   #if FRAMEWORK_OPTIONS_KEYER_OPTIONS_RATIO
   { "-ratio",	 "ratio",    "Ratio",    "50",	    fw_option_float,    fw_flag_none,	    offsetof(_t, opts.ratio),	  "keyer dit/dah ratio" },
   #endif
   #if FRAMEWORK_OPTIONS_KEYER_OPTIONS_COMP
   { "-comp",     "comp",     "Comp",      "0",	    fw_option_float,    fw_flag_none,	    offsetof(_t, opts.comp),       "keyer ms compensation" },
   #endif
	parts per thousand = per mille = â€°
	    {* -weight} - 
	    {* -ratio} { $self describe $option value -format %.1f -min 25.0 -max 75.0 -step 0.1 -units % -graticule 20 -steps-per-div 50}
	    {* -comp} { $self describe $option value -format %.1f -min -15.0 -max 15.0 -step 0.1 -units ms -graticule 20 -steps-per-div 50}
      float r = (dp->opts.ratio-50)/100.0; // why 50 is zero is left as an exercise
      float w = (dp->opts.weight-50)/100.0;
      float c = 1000.0 * dp->opts.comp / microsPerDit;
      dp->k.k.setTiming(1000000.0  / sdrkit_sample_rate(dp),
			dp->opts.wpm, 
			dp->opts.word, 
			dp->opts.dit+r+w+c, 
			dp->opts.dah-r+w+c,
			dp->opts.ies  -w-c, 
			dp->opts.ils  -w-c, 
			dp->opts.iws  -w-c);
** [x] collapse out some irrelevant UI components
** [x] hide/show parts of settings according to properties
   I can do this by conditionally including/excluding html`` for each part,
   however, I think lit-html works better if I render the whole thing and
   mark parts as displayed/hidden according to the same conditions.
   so that's the css property { display: none; } to disappear,
   { display: block } to show a div.  No, that's not working with either
   of the lit-html directives classMap or styleMap.
   Menu marker and other useful characters:
***   &#x23f4; left filled triangle
***   &#x23f5; right filled triangle
***   &#x23f6; up filled triangle
***   &#x23f7; down filled triangle
***   &#9776; hamburger menu, all yang trigram
***   &#x23F5; Play button
***   &#x25B6; Play button emoji
***   &#xe23a; Play button emoji
***   &#x23F8; Pause button    
***   &#xFE0F; Pause button emoji
** [?] Rewriting pulse shaping using independently timed buffers was too frustrating,
   couldn't find a way to do it and backed out.  Got glitches between buffers.
* The editable keyboard input
  Using content editable results in a weird out of control input widget
  Not using content editable means you can't use the text cursor to mark
  the input insertion point.
  So, make a software cursor?  Put a timer on the blink.
